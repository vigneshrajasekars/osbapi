/*
 * Open Service Broker API
 *
 * The Open Service Broker API defines an HTTP(S) interface between Platforms and Service Brokers.
 *
 * API version: master - might contain changes that are not yet released
 * Contact: open-service-broker-api@googlegroups.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
	openapi "github.com/openservicebrokerapi/osb-checker/autogenerated/models"
	"github.com/openservicebrokerapi/osb-checker/mockbroker/store"
	"github.com/openservicebrokerapi/osb-checker/mockbroker/utils"
)

var (
	maxInstanceLastOperationQueries MaxLastOperationQueries = 3
)

type MaxLastOperationQueries int64

func (m *MaxLastOperationQueries) Reset() {
	*m = 3
}

// ServiceInstanceDeprovision - deprovision a service instance
func ServiceInstanceDeprovision(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID := mux.Vars(r)["instance_id"]
	qMap := r.URL.Query()
	// check if the request support async
	if async := qMap.Get("accepts_incomplete"); async != "true" {
		errMsg := fmt.Sprintf("accepts_incomplete expected true, got %s", async)
		log.Println(errMsg)
		handleError(w, 422, "Unprocessable Entity", errMsg)
		return
	}
	// validate if request params is validated
	svcID, planID := qMap.Get("service_id"), qMap.Get("plan_id")
	if svcID == "" || planID == "" {
		errMsg := fmt.Sprint("service_id or plan_id should not be empty")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	// return 410 if service instance is gone
	if !store.CheckIfServiceInstanceExists(svcID, planID, insID) {
		errMsg := fmt.Sprintf("service instance (%s) doesn't exist", insID)
		log.Println(errMsg)
		handleError(w, 410, "Gone", errMsg)
		return
	}
	// remove service instance from store.ServiceInstancePayloadList
	store.RemoveServiceInstancePayload(svcID, planID, insID)
	log.Printf("service instance (%s) removed successfully\n", insID)

	handleResult(w, 202, &openapi.AsyncOperation{})
	return
}

// ServiceInstanceGet - gets a service instance
func ServiceInstanceGet(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID := mux.Vars(r)["instance_id"]
	// find the specified instance, and return 404 if not found
	payload, err := store.FindServiceInstancePayload(insID)
	if err != nil {
		errMsg := fmt.Sprintf("service instance (%s) doesn't exist", insID)
		log.Println(errMsg)
		handleError(w, 404, "Not Found", errMsg)
		return
	}

	handleResult(w, 200, payload.Payload)
	return
}

// ServiceInstanceLastOperationGet - last requested operation state for service instance
func ServiceInstanceLastOperationGet(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	// run in a loop for three times and return in progress state
	if maxInstanceLastOperationQueries > 0 {
		maxInstanceLastOperationQueries = maxInstanceLastOperationQueries - 1
		handleResult(w, 200, &openapi.LastOperationResource{
			State:       "in progress",
			Description: "creating service",
		})
		return
	}

	// finish the loop and return succeeded state
	maxInstanceLastOperationQueries.Reset()
	handleResult(w, 200, &openapi.LastOperationResource{
		State:       "succeeded",
		Description: "created service",
	})
	return
}

// ServiceInstanceProvision - provision a service instance
func ServiceInstanceProvision(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID := mux.Vars(r)["instance_id"]
	qMap := r.URL.Query()
	// check if the request support async
	if async := qMap.Get("accepts_incomplete"); async != "true" {
		errMsg := fmt.Sprintf("accepts_incomplete expected true, got %s", async)
		log.Println(errMsg)
		handleError(w, 422, "Unprocessable Entity", errMsg)
		return
	}
	// validate if request params is validated
	var req openapi.ServiceInstanceProvisionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	svcID, planID := req.ServiceId, req.PlanId
	orgGUID, spcGUID := req.OrganizationGuid, req.SpaceGuid
	if svcID == "" || planID == "" || orgGUID == "" || spcGUID == "" {
		errMsg := fmt.Sprint("service_id or plan_id or organization_guid or space_guid should not be empty")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if !store.CheckIfServiceIDExists(svcID) || !store.CheckIfPlanIDExists(svcID, planID) {
		errMsg := fmt.Sprint("service_id or plan_id doesn't exist")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if err := utils.ParametersSchemaCheck(*store.GetCatalogPayload(), &utils.SchemaOpts{
		ServiceID:  svcID,
		PlanID:     planID,
		Parameters: req.Parameters,
		SchemaType: "service_instance",
		Action:     "create",
	}); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	// return 409 Conflict if find service instance exists with different properties
	if store.CheckIfServiceInstanceExistsWithDifferentProperties(svcID, planID, insID, req.Parameters) {
		errMsg := fmt.Sprintf("service instance (%s) exists with different properties", insID)
		log.Println(errMsg)
		handleError(w, 409, "Conflict", errMsg)
		return
	}
	// return 200 OK if find service instance exists
	if store.CheckIfServiceInstanceExists(svcID, planID, insID) {
		log.Printf("service instance (%s) already exists\n", insID)
		payload, _ := store.FindServiceInstancePayload(insID)
		handleResult(w, 200, &openapi.ServiceInstanceProvisionResponse{
			DashboardUrl: payload.Payload.DashboardUrl,
		})
		return
	}
	// generate instance payload and store it in store.ServiceInstancePayloadList
	instancePayload := &store.ServiceInstancePayload{
		InstanceID: insID,
		Payload: &openapi.ServiceInstanceResource{
			ServiceId:  svcID,
			PlanId:     planID,
			Parameters: req.Parameters,
		},
	}
	store.StoreServiceInstancePayload(instancePayload)
	log.Printf("new service instance (%s) stored successfully\n", insID)

	// return 202 Accepted after everything done
	handleResult(w, 202, &openapi.ServiceInstanceAsyncOperation{})
	return
}

// ServiceInstanceUpdate - update a service instance
func ServiceInstanceUpdate(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID := mux.Vars(r)["instance_id"]
	qMap := r.URL.Query()
	// check if the request support async
	if async := qMap.Get("accepts_incomplete"); async != "true" {
		errMsg := fmt.Sprintf("accepts_incomplete expected true, got %s", async)
		log.Println(errMsg)
		handleError(w, 422, "Unprocessable Entity", errMsg)
		return
	}
	// validate if request params is validated
	var req openapi.ServiceInstanceUpdateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	svcID, planID := req.ServiceId, req.PlanId
	if svcID == "" {
		errMsg := fmt.Sprint("service_id should not be empty")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if !store.CheckIfServiceIDExists(svcID) {
		errMsg := fmt.Sprint("service_id doesn't exist")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if err := utils.ParametersSchemaCheck(*store.GetCatalogPayload(), &utils.SchemaOpts{
		ServiceID:  svcID,
		PlanID:     planID,
		Parameters: req.Parameters,
		SchemaType: "service_instance",
		Action:     "update",
	}); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	// return 200 OK if find service instance exists with exactly same properties.
	if store.CheckIfServiceInstanceExists(svcID, planID, insID) &&
		!store.CheckIfServiceInstanceExistsWithDifferentProperties(svcID, planID, insID, req.Parameters) {
		log.Printf("service instance (%s) already exists\n", insID)
		handleResult(w, 200, emptyBody)
		return
	}
	// refresh service instance in store.ServiceInstancePayloadList
	store.RefreshServiceInstancePayload(insID, planID, req.Parameters)
	log.Printf("service instance (%s) updated successfully\n", insID)

	// return 202 Accepted after everything done
	handleResult(w, 202, &openapi.ServiceInstanceAsyncOperation{})
	return
}
