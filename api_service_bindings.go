/*
 * Open Service Broker API
 *
 * The Open Service Broker API defines an HTTP(S) interface between Platforms and Service Brokers.
 *
 * API version: master - might contain changes that are not yet released
 * Contact: open-service-broker-api@googlegroups.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
	openapi "github.com/openservicebrokerapi/osb-checker/autogenerated/models"
	"github.com/openservicebrokerapi/osb-checker/mockbroker/store"
	"github.com/openservicebrokerapi/osb-checker/mockbroker/utils"
)

var (
	maxBindingLastOperationQueries MaxLastOperationQueries = 3
)

// ServiceBindingBinding - generation of a service binding
func ServiceBindingBinding(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID, bidID := mux.Vars(r)["instance_id"], mux.Vars(r)["binding_id"]
	qMap := r.URL.Query()
	// check if the request support async
	if async := qMap.Get("accepts_incomplete"); async != "true" {
		errMsg := fmt.Sprintf("accepts_incomplete expected true, got %s", async)
		log.Println(errMsg)
		handleError(w, 422, "Unprocessable Entity", errMsg)
		return
	}
	// validate if request params is validated
	var req openapi.ServiceBindingRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	svcID, planID := req.ServiceId, req.PlanId
	if svcID == "" || planID == "" {
		errMsg := fmt.Sprint("service_id or plan_id should not be empty")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if !store.CheckIfServiceIDExists(svcID) || !store.CheckIfPlanIDExists(svcID, planID) {
		errMsg := fmt.Sprint("service_id or plan_id doesn't exist")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	if err := utils.ParametersSchemaCheck(*store.GetCatalogPayload(), &utils.SchemaOpts{
		ServiceID:  svcID,
		PlanID:     planID,
		Parameters: req.Parameters,
		SchemaType: "service_binding",
		Action:     "create",
	}); err != nil {
		errMsg := fmt.Sprintf("request params validate failed: %v", err)
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	// return 409 Conflict if find service binding exists with different properties
	if store.CheckIfServiceBingdingExistsWithDifferentProperties(svcID, planID, insID, bidID, req.Parameters) {
		errMsg := fmt.Sprintf("service binding (%s) exists with different properties", bidID)
		log.Println(errMsg)
		handleError(w, 409, "Conflict", errMsg)
		return
	}
	// return 200 OK if find service binding exists
	if store.CheckIfServiceBindingExists(svcID, planID, insID, bidID) {
		log.Printf("service binding (%s) already exists\n", bidID)
		payload, _ := store.FindServiceBindingPayload(insID, bidID)
		handleResult(w, 200, &openapi.ServiceBindingResponse{
			Credentials: payload.Payload.Credentials,
		})
		return
	}
	// generate binding payload and store it in store.ServiceBindingPayloadList
	bindingPayload := &store.ServiceBindingPayload{
		ServiceID:  svcID,
		PlanID:     planID,
		InstanceID: insID,
		BindingID:  bidID,
		Payload: &openapi.ServiceBindingResource{
			Credentials: store.CredentialsPayload,
			Parameters:  req.Parameters,
		},
	}
	store.StoreServiceBindingPayload(bindingPayload)
	log.Printf("new service binding (%s) stored successfully\n", bidID)

	// return 202 Accepted after everything done
	handleResult(w, 202, &openapi.AsyncOperation{})
	return
}

// ServiceBindingGet - gets a service binding
func ServiceBindingGet(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID, bidID := mux.Vars(r)["instance_id"], mux.Vars(r)["binding_id"]
	// find the specified binding, and return 404 if not found
	payload, err := store.FindServiceBindingPayload(insID, bidID)
	if err != nil {
		errMsg := fmt.Sprintf("service binding (%s) doesn't exist", bidID)
		log.Println(errMsg)
		handleError(w, 404, "Not Found", errMsg)
		return
	}

	handleResult(w, 200, payload.Payload)
	return
}

// ServiceBindingLastOperationGet - last requested operation state for service binding
func ServiceBindingLastOperationGet(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	// run in a loop for three times and return in progress state
	if maxBindingLastOperationQueries > 0 {
		maxBindingLastOperationQueries = maxBindingLastOperationQueries - 1
		handleResult(w, 200, &openapi.LastOperationResource{
			State:       "in progress",
			Description: "creating service",
		})
		return
	}

	// finish the loop and return succeeded state
	maxBindingLastOperationQueries.Reset()
	handleResult(w, 200, &openapi.LastOperationResource{
		State:       "succeeded",
		Description: "created service",
	})
	return
}

// ServiceBindingUnbinding - deprovision of a service binding
func ServiceBindingUnbinding(w http.ResponseWriter, r *http.Request) {
	// check if request header is validated
	flag, errFunc := checkRequestHeader(w, r)
	if !flag {
		errFunc(w)
		return
	}

	insID, bidID := mux.Vars(r)["instance_id"], mux.Vars(r)["binding_id"]
	qMap := r.URL.Query()
	// check if the request support async
	if async := qMap.Get("accepts_incomplete"); async != "true" {
		errMsg := fmt.Sprintf("accepts_incomplete expected true, got %s", async)
		log.Println(errMsg)
		handleError(w, 422, "Unprocessable Entity", errMsg)
		return
	}
	// validate if request params is validated
	svcID, planID := qMap.Get("service_id"), qMap.Get("plan_id")
	if svcID == "" || planID == "" {
		errMsg := fmt.Sprint("service_id or plan_id should not be empty")
		log.Println(errMsg)
		handleError(w, 400, "Bad Request", errMsg)
		return
	}
	// return 410 if service binding is gone
	if !store.CheckIfServiceBindingExists(svcID, planID, insID, bidID) {
		errMsg := fmt.Sprintf("service instance (%s) doesn't exist", insID)
		log.Println(errMsg)
		handleError(w, 410, "Gone", errMsg)
		return
	}
	// remove service instance from store.ServiceInstancePayloadList
	store.RemoveServiceBindingPayload(svcID, planID, insID, bidID)
	log.Printf("service binding (%s) removed successfully\n", bidID)

	handleResult(w, 202, &openapi.AsyncOperation{})
	return
}
